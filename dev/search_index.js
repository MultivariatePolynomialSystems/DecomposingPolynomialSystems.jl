var documenterSearchIndex = {"docs":
[{"location":"symmetries/deck/#Deck-transformations","page":"Deck transformations","title":"Deck transformations","text":"","category":"section"},{"location":"symmetries/deck/","page":"Deck transformations","title":"Deck transformations","text":"Deck transformations of a parametric polynomial system are the birational maps that fix the parameters of the polynomial system.","category":"page"},{"location":"symmetries/deck/#Computing-deck-transformations","page":"Deck transformations","title":"Computing deck transformations","text":"","category":"section"},{"location":"symmetries/deck/","page":"Deck transformations","title":"Deck transformations","text":"symmetries_fixing_parameters","category":"page"},{"location":"symmetries/deck/#DecomposingPolynomialSystems.symmetries_fixing_parameters","page":"Deck transformations","title":"DecomposingPolynomialSystems.symmetries_fixing_parameters","text":"symmetries_fixing_parameters(F::System; degree_bound=1, param_dep=true, kwargs...)\n\nGiven a polynomial system F returns the group of symmetries  of F that fix the parameters. The keyword argument degree_bound is used to set the upper bound for the degrees of numerator and denominator polynomials in expressions for the symmetries. The param_dep keyword argument specifies whether to consider functions of the symmetries to be dependent on the parameters of F.\n\njulia> @var x[1:2] p[1:2];\n\njulia> F = System([x[1]^2 - x[2]^2 - p[1], 2*x[1]*x[2] - p[2]]; variables=x, parameters=p);\n\njulia> symmetries_fixing_parameters(F; degree_bound=1, param_dep=false)\nDeckTransformationGroup of order 4\n structure: C2 x C2\n action:\n  1st map:\n   x₁ ↦ x₁\n   x₂ ↦ x₂\n  2nd map:\n   x₁ ↦ -x₁\n   x₂ ↦ -x₂\n  3rd map:\n   x₁ ↦ im*x₂\n   x₂ ↦ -im*x₁\n  4th map:\n   x₁ ↦ -im*x₂\n   x₂ ↦ im*x₁\n\n\n\n\n\n","category":"function"},{"location":"symmetries/deck/#DeckTranfromationGroup","page":"Deck transformations","title":"DeckTranfromationGroup","text":"","category":"section"},{"location":"symmetries/deck/","page":"Deck transformations","title":"Deck transformations","text":"DeckTransformationGroup","category":"page"},{"location":"symmetries/deck/#DecomposingPolynomialSystems.DeckTransformationGroup","page":"Deck transformations","title":"DecomposingPolynomialSystems.DeckTransformationGroup","text":"DeckTransformationGroup\n\nA DeckTransformationGroup is the result of deck transformations computation.\n\n\n\n\n\n","category":"type"},{"location":"symmetries/scalings/#Scaling-symmetries","page":"Scaling symmetries","title":"Scaling symmetries","text":"","category":"section"},{"location":"symmetries/scalings/","page":"Scaling symmetries","title":"Scaling symmetries","text":"Scaling symmetries of a (parametric) polynomial system are the maps that act by scaling individual variables of the formulation. ","category":"page"},{"location":"symmetries/scalings/#Computing-scaling-symmetries","page":"Scaling symmetries","title":"Computing scaling symmetries","text":"","category":"section"},{"location":"symmetries/scalings/","page":"Scaling symmetries","title":"Scaling symmetries","text":"scaling_symmetries","category":"page"},{"location":"symmetries/scalings/#DecomposingPolynomialSystems.scaling_symmetries","page":"Scaling symmetries","title":"DecomposingPolynomialSystems.scaling_symmetries","text":"scaling_symmetries(F::System)\n\nGiven a polynomial system F returns the group of scaling symmetries  of F. The scalings that change the parameters are considered as well.\n\njulia> @var x y a b c;\n\njulia> F = System([x^4+a^2+1, y^2+b+c]; variables=[x, y], parameters=[a,b,c]);\n\njulia> scaling_symmetries(F)\nScalingGroup isomorphic to ℤ × ℤ₄ × ℤ₂\n 1 free scaling:\n  y ↦ y*λ, b ↦ b*λ^2, c ↦ c*λ^2\n\n modular scalings:\n  1 of order 4:\n   x ↦ -im*x, y ↦ im*y, b ↦ -b, c ↦ -c\n  1 of order 2:\n   x ↦ -x, y ↦ -y, a ↦ -a\n\n\n\n\n\n","category":"function"},{"location":"symmetries/scalings/#ScalingGroup","page":"Scaling symmetries","title":"ScalingGroup","text":"","category":"section"},{"location":"symmetries/scalings/","page":"Scaling symmetries","title":"Scaling symmetries","text":"ScalingGroup","category":"page"},{"location":"symmetries/scalings/#DecomposingPolynomialSystems.ScalingGroup","page":"Scaling symmetries","title":"DecomposingPolynomialSystems.ScalingGroup","text":"ScalingGroup\n\nA ScalingGroup is the result of the scaling_symmetries computation.\n\n\n\n\n\n","category":"type"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DecomposingPolynomialSystems.jl is a Julia package for decomposing systems of polynomial equations, i.e. representing a possibly complicated polynomial system as an equivalent sequence of simpler polynomial systems.","category":"page"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TBW","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SampledSystem","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"sampled_system.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Computing symmetries","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"symmetries/scalings.md\",\n    \"symmetries/deck.md\",\n]\nDepth = 2","category":"page"},{"location":"sampled_system/#SampledSystem","page":"SampledSystem","title":"SampledSystem","text":"","category":"section"},{"location":"sampled_system/","page":"SampledSystem","title":"SampledSystem","text":"SampledSystem is a struct type that initially contains a polynomial system, the result of monodromy computations, and the solutions-parameters samples obtained by monodromy or further by additional tracking. This is the return type of run_monodromy and sample!.","category":"page"},{"location":"sampled_system/#Run-monodromy","page":"SampledSystem","title":"Run monodromy","text":"","category":"section"},{"location":"sampled_system/","page":"SampledSystem","title":"SampledSystem","text":"run_monodromy","category":"page"},{"location":"sampled_system/#DecomposingPolynomialSystems.run_monodromy","page":"SampledSystem","title":"DecomposingPolynomialSystems.run_monodromy","text":"run_monodromy(F::Union{System, AbstractSystem}, xp₀=nothing; options...) -> SampledSystem\n\nRuns monodromy_solve on a given polynomial system F with starting solutions xp₀[1] and parameters xp₀[2] (if given).\n\njulia> @var x a b;\n\njulia> F = System([x^3+a*x+b]; variables=[x], parameters=[a,b]);\n\njulia> F = run_monodromy(F, ([[1]], [1,-2]), max_loops_no_progress = 10)\nSampledSystem with 3 samples\n 1 unknown: x\n 2 parameters: a, b\n\n number of solutions: 3\n sampled instances: 1\n\n\n\n\n\nrun_monodromy(F::SampledSystem, xp₀=nothing; options...) -> SampledSystem\n\nReruns monodromy_solve on a given sampled polynomial system F.\n\n\n\n\n\n","category":"function"},{"location":"sampled_system/#Sample-system","page":"SampledSystem","title":"Sample system","text":"","category":"section"},{"location":"sampled_system/","page":"SampledSystem","title":"SampledSystem","text":"sample!","category":"page"},{"location":"sampled_system/#DecomposingPolynomialSystems.sample!","page":"SampledSystem","title":"DecomposingPolynomialSystems.sample!","text":"sample!(F::SampledSystem; path_ids=Vector(1:nsolutions(F)), n_instances=1) -> SampledSystem\n\nTBW\n\n\n\n\n\n","category":"function"}]
}
